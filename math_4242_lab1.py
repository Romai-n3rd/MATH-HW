# -*- coding: utf-8 -*-
"""Math_4242_Lab1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10YxcFUCimFqDFdsdxxEFIcTOR3HEQjP9

# Activity 1: Introduction to Python and NumPy
## What is this?

Welcome to MATH 4242!
In these activities, we'll be exploring the material from class with hands-on computational activities.
One goal is to teach the usage of three key tools in concert with each other:

- **Python:** Python 3 is the programming language we'll be using for the semester.
Python is very versatile, and can be used in a great variety of ways for many different purposes.
Some of these purposes common today include data science and machine learning, in part motivating the decision to use it for MATH 4242.
Python is highly *extensible* meaning that in addition to the functionality offered by "base" Python, there are a great many *libraries* made by Python developers around the world which add additional features.
One of these libraries in particular will be highly relevant to us:
- **NumPy:**  NumPy (**Num**erical **Py**thon) is a Python library which adds better support for numerical computations, particularly in linear algebra.
NumPy provides the `ndarray` data type which will be our primary method of modeling matrices and vectors, as well as an extensive selection of tools for manipulating them.

- **jupyter:** Jupyter is the platform you're using right now!
Jupyter provides *notebooks,* which are the environment this is appearing in.
A notebook is comprised of *cells* which may contain *markdown* or code.
- **Markdown** is a way of encoding formatted text.
This cell is an example of markdown!

### How to use these notebooks
These activities are intended to be truly **interactive**.
Some example code will be provided, but whether in the context of an exercise or an example, you will be asked to fill many of the code cells. Especially in examples, you are invited and encouraged to discuss strategy and technique with your classmates and TA.
Crucially, you are **strongly encouraged** never to run code without at least attempting to understand what it will do (or at least, not to move on to the next thing until you have understood the previous).
Some very helpful tools are at your disposal to that end:

- You can always add an additional code cell to a notebook to experiment!
You are encouraged to do this frequently!
- You can read the documentation for various function by using the `help` function. For instance, here is how we can get more information about the `abs` function:
    ```Python
    help(abs)
    ```
    This returns:
    ```
    Help on built-in function abs in module builtins:

    abs(x, /)
        Return the absolute value of the argument.
    ```
    You can also find documentation for all NumPy functions and objects on the [NumPy website](https://numpy.org/doc/2.1/) and all Python functions and objects on the [Python website](https://docs.python.org/3/).
- Google and other search engines such as duckduckgo are your friend! When stuck, a good way to get going is to simply search "NumPy [quick description of what you are stuck with]."
Often, the most helpful results are from the [Stack Exchange](https://stackexchange.com/) family of websites.

- You are **strongly discouraged** from using generative AI to answer questions.
While Google CoLab does have generative AI features built-in, we urge you to resist its pull.
Although generative AI is fairly well-suited to the rather basic programming tasks you'll be asked to complete, **using it is only doing a disservice to yourself.**
Indeed, thinking through how to implement these algorithms and translating your knowledge from class into computerized instructions is *the point* of these activities.
Mathematics is not a spectator sport!
You will make a much more lasting impression for yourself if you allow yourself the frustration and eventual joy of doing it yourself than you would by reading the code written by a generative AI-powered assistant.

Each time you are asked to provide code, there will be a *test* for your code below the relevant code cell.
Usually, there will be a comment in that cell with the desired output.
If your output matches that comment, you know that your code at least works in that instance!
Sometimes no desired output is provided. In that case, it is because there are theoretical methods to anticipate what the output should be from lecture or the textbook.
If you don't know what the test should output, discuss with a classmate or your TA!
Whether a test is provided or not, you are very much encouraged to write your own!

To try out getting help, in the code cell below, use the `help` function to bring up help on the Python built-in `max` function.
"""

help(max)

"""##  Python: variables, numbers, objects, types, strings, lists
This is intended as a very quick introduction.
You are encouraged to seek out more resources to gain more familiarity and comfort with the language.
For example, [this](https://www.w3schools.com/python/python_intro.asp) is a free tutorial which goes in significantly more depth.

### Variables, Numbers, and Booleans

One of the most basic features of the python language are *variables*.
These are names which in general reference *data types*.
We'll see examples of more complex types later, but let's start with some simple ones, such as numerical types.
The following example makes use of the `print` function, which as you'll see provides information about its argument to output.
**To evaluate a jupyter cell, hit shift-enter after selecting that cell.**
"""

a=9
b=3
print(a+b) # addition
print(a*b) # multiplication
print(a-b) # subtraction

"""Much of Python's syntax is quite intuitive, but there are a few quirks to get used to."""

print(a^b) # surprise! was that what you expected?
print(a**b) # what do these last two do?



"""As you've now seen, exponentiation was handled differently than you may have expected.
`^` is reserved for *bitwise xor*, while **exponentiation is represented with `**`.**
<details>
    <summary>
        <b>
            More on ^
        </b>
        (Click to expand)
    </summary>

We won't be using `^` during the course of these activities (at least unless you happen to find creative ways of doing so). We can, however, briefly explain what it does. On bits (i.e. 1 or 0), `a^b` returns `1` if exactly one of `a` and `b` is equal to `1` and 0 if both are 0 or both are 1.
On strings of bits (e.g. `1001` or `0011`), bitwise xor acts by applying to each bit one-by-one.
So in this example, we would see that `(1001)^(0011)` is `1010`.

Of course, as you may know, computers represent numbers as binary strings. $9=1*2^3+0*2^2+0*2^1+2^0$, so we would represent 9 as `1001`, and $3=0*2^3+0*2^2+1*2^1+2^0$, so we would represent 3 as `0011`. Then, the result of `9^3` above is `1010`, which we read as $1*2^3+0*2^2+1*2^1+0*2^0=10$. Indeed, that's what we got when we tried it!
</details>
One other subtlety comes about in division.
Try out the following example.
"""

print(a//b) # what is this?
print(a/b)  # how about this?

"""Those were the same, but now **you try!** With $a=8$ and $b=3$, what do you get for `a/b` and `a//b`?"""

a=8
b=3
print(a//b)
print(a/b)

"""Every object in Python has a *type*.
You can check types using the `type` function.
For example, try checking the type of `a` and `a/b` below.
"""

type(a)

type(a/b)

"""Note they are different!
The `int` type is used to represent whole numbers, while the `float` type is used to represent decimals.
In our applications, we will be primarily working with `float`s.
For the most part, we'll be able to sidestep these subtleties, but there will be cases in which some care will be necessary.

### Booleans and Comparisons
Another highly fundamental type is that of the boolean, implemented in Python as the `bool` type.
There are two tokens belonging to the type: `True` and `False`.
There are some very common functions of booleans which are built-in to Python: `and` and `or`, and the operator `not`.
"""

A=True
B=True
print(A and B)
print(A or B)
print(not B)
print((not A) and B)

"""One place where `bool`s very frequently come up is comparison:
- `==` checks for equality
- `>` and `<` check for greater and less than respectively
- `>=` and `<=` check for greater than or equal to and less than or equal to respectively.
"""

#what do you expect this to print?
a=5
b=6
c=5/6
print(a>b)
print(a<b)
print(a/b > c)
print(a/b >=c)
print(a/b==c)

"""### Strings and Lists

Another object which will come up for us are `string`s.
These are a mode of storing text.
Take a look at the example below.

"""

a= "Hello"
b= " "
c= "World"
d= "!"
print(a+c+d)
print(a*15)

a= "Hello"
b= " "
c= "World"
d= "!"
print(a+c+d)
print(a*15)

"""**You try!** Try to come up with a way to print "Hello!!!" 20 times, with a space in between each instance."""

a= "Hello"
b= " "
c= "World"
d= "!"
print((a+d*3+b)*20)

"""Strings behave similarly to another important data type, that of the `list`.
To form a `list`, simply put a sequence of values, separated by commas, into square brackets `[]`.
For example, here is a list of some strings.
"""

A=[a+b+c+d,
   a+2*b+3*c+4*d,
   d+2*c+3*b+4*a,
   a+d+c+d+a+d,
   5*(a+d+b),
   3*(c+d+b)]
A

"""`len` gives the length of a list."""

len(A)

"""Lists are *indexed* with square brackets as well.
This is, in essence, a means of calling elements of a list or a range within.
Here's an example using the previous list:
"""

print(A[0])     #lists are always indexed starting at 0
print(A[5])     #our list has six elements, so 5 is the last one (since we started at 0)
print(A[-1])    #negative indexing starts at the end with -1 (so this is the same as A[5])
print(A[1:3])   #gives list items 1 and 2 (in general, it includes the part before the colon, but not the part after)
print(A[2:])    #start at item 2 (inclusive) until the end
print(A[:3])    #start at the beginning and end at item 3 (exclusive)

"""**You try!** print the list that starts at the beginning and ends after item 3 (`'Hello!World!Hello!'`). Then, print the list that starts at item 4 and goes until the end."""

A=[a+b+c+d,
   a+2*b+3*c+4*d,
   d+2*c+3*b+4*a,
   a+d+c+d+a+d,
   5*(a+d+b),
   3*(c+d+b)]
A
print(A[3:])

"""The same indexing works on strings:"""

f=5*(a+b+c+d)
print(f[6:25])
print(f[6:25:2]) #The third digit tells us to increment by that many as we go from item to item
print(f[24:5:-1]) #it accepts negative arguments

"""Now **you try!** How would you print starting six characters from the end and ending on the sixth character, incrementing backwards and skipping every other letter?"""

f=5*(a+b+c+d)
print(4*f[6:400:10]+f[6])
#desired output:
#WolHdrWolHdrWolHdrWolHdrW

"""We'll be revisiting lists in greater detail soon once we start working with NumPy!
## Control Sequences: Conditionals, Loops, Iteration, and Functions
### If and Else

Control sequences let us structure our code into blocks and provide a logical flow to our programs.
Perhaps the most basic of these is the conditionals `if` and `else`.
The basic syntax for these is:
```python
if x:
    y
else:
    z
```
Here, `x` is a `bool` and `y` and `z` are ensuing code (which can be multi-line).
Note the spacing.
**Any control block starts with a line ending with a colon.
Any subsequent code within the control block then must have a tab at the beginning of the line.**
As an example, play around with the following by changing the value of `num` in the first line.
"""

num = 3
if num % 2 ==0:       #the % symbol is the remainder-- i.e. if num has a remainder of 0 after being divided by 2
    print("even")
else:
    print("odd")

"""** You try!** Rework the example below to write code which prints `num/2` if `num` is even, `(num-1)/2` if `num` is odd and negative, and `(num+1)/2` if `num` is odd and positive.
(You can do this by nesting `if` and `else` statements, or using the `elif` control sequence).
"""

x = -1
if x % 2 ==0:       #the % symbol is the remainder-- i.e. if num has a remainder of 0 after being divided by 2
    print(x/2)
elif x < 0:
    print((x-1)/2)
else:
    print((x+1)/2)

"""### Loops
Often, we'll want to automate repetitive tasks.
Python supplies *loops* for this purpose.
For instance, suppose I have a recursive function given by the formula $a_n=(1-2a_{n-1})/3$ and wanted to know what $a_10$ would be if I started with $a_0=1$.
The following loop does just that:
"""

a=1
for n in range(10):   #This says I am letting n=0, performing the code below it, then letting n=1, then n=2, etc. through n=9.
    #It is exclusive of the argument (so range(10) is 0,1,2,...,9, *not* including 10).
    #Notice the colon at the end! You will get an error without one!
    #each new line in the loop must start with a tab
    print("a_",n,"=",a) #check in on current value--think through why the indexing makes sense!
    a=(1-2*a)/3         #find a_n from a_{n-1}
a   #this is outside of the loop because it doesn't start with a tab

"""Note that in the line `a=(1-2*a)/3`, we referenced the value of the variable we were changing!

#### Exercise 1: Looping to Compute Recursive Sequences
**Exercise: (a):** Alter the above to compute the 15th term of the recursive sequence $b_n=(1+2b_{n-1})/4$ starting with $b_0=2$.
To check that your code is working as intended, here's the first few terms:
```
b_ 0 = 2
b_ 1 = 1.25
b_ 2 = 0.875
b_ 3 = 0.6875
```

"""

b=2
for n in range(16):
    print("b_",n,"=",b)
    b=(1+2*b)/4

"""___

**(b)** Consider the *two-variable* recursion given by $c_n=\frac{(c_{n-1}+d_{n-1})}{2c_{n-1}d_{n-1}}$ , $d_n=\frac{c_{n-1}^2}{c_{n-1}+d_{n-1}}$. Find $c_{20}$ and $d_{20}$ when $c_0=d_0=1$. Like before, print out $c_n$ and $d_n$ for each $n$.

To check your sequence is working, here are the first few terms:
```
c_ 0 = 1 ; d_ 0 = 1
c_ 1 = 1.0 ; d_ 1 = 0.5
c_ 2 = 1.5 ; d_ 2 = 0.6666666666666666
c_ 3 = 1.0833333333333333 ; d_ 3 = 1.0384615384615385
```

<details>
    <summary> <b> Hint:</b> (click here to open)</summary>

- if you copy the method of the above exactly, you may find yourself overwriting variables you need to store. Introducing a new variable (say, "`a_last`") is one way out of that pickle.    
</details>
"""

c=1
d=1
for n in range(21):
    print("c_",n,"=",c," ","d_",n,"=",d)
    e = d
    d=(c**2)/(c+d)
    c=(c+e)/(2*c*e)

"""___

### Functions

Sometimes, we'll want to perform the same process to a variety of different inputs.
As a first example, one classic example is the factorial $n!$.
Below is a somewhat nonstandard implementation of the factorial--in a moment, we'll explain why we say this is nonstandard.
"""

def my_factorial(n):
    #
    #once again, the colon is necessary and everything within the function will start with a tab
    prod=1                  #initialize
    for k in range(1,n+1):  #This syntax means start at 1 and stop at n+1, excluding n+1 (so k=1,2,...,n)
        print(k)            #strictly unnecessary, for illustrative purposes
        prod=prod*(k)
    return prod

my_factorial(0) #check this works correctly for n=0

my_factorial(5)

"""**Your turn** find 8! with `my_factorial`."""

my_factorial(8)

"""Functions can take more than just one argument as input.
For instance, we can alter our code from the example above to compute $a_N$ for any $N$ and any value for $a_0$, rather than just $N=10$ and $a_0=1$.
"""

def a_N(N,a_0):  #This says our function takes two arguments, N and a_0
    a=a_0         #generalizing from above--a is the variable we'll work with, a_0 is supplied by argument
    for n in range(N): # generalizing from above
        #now, we need two tabs to place code in the loop.
        print("a_",n,"=",a)
        a=(1-2*a)/3
    return a      #every function has to end with a return line
a_N(20,3)  #This finds a_20 with a_0=3.
           #the value at the bottom is what is computed in the line starting with "return"

"""#### Exercise 2(a): Functions of your own!
**(a)** Similar to above, return to your code from exercise 1(a) and generalize it to a function `b_N` which take arguments `N` and `b_0` and returns the `N`th term of the recursive sequence defined by $b_n=(1+2b_{n-1})/4$ where $b_0$ is given by the argument `b_0`.
Once again, your function should print the current value of $b_n$ at each $n$.
To make sure your function is correct, you are given that when $b_0=10000$, $b_{23}=0.501192033290863$.
"""

#YOUR CODE HERE
def b_N(N,b_0):
    b=b_0
    for n in range(N):
        print("b_",n,"=",b)
        b=(1+2*b)/4
    return b
b_N(23,10000)

"""___

We can write a function which performs the same using *recursion*.
This is a function which calls itself to compute.
This is best illustrated with a classic example.
Recall that the factorial $n!$ is defined as $n*(n-1)*\dots *2*1$ with the convention that $0!=1$.
Equivalently, $n!$ can be defined as $n*(n-1)!$ along with the declaration $0!=1$.
The following uses this latter definition to define the factorial in Python.
This is the much more commonly seen method of defining the factorial.

*Note:* The `print` statements are for illustrative purposes only.
How does the printed output of `my_factorial` differ from that of `my_factorial_recursive`?
Why do you think that is?
"""

def my_factorial_recursive(n):
    if n==0:
        print(n)
        return 1
    else:
        print(n)
        return n*my_factorial_recursive(n-1)

my_factorial_recursive(15)

my_factorial(15)

"""We can also give a recursive definition of `a_N`."""

def recursive_a_N(N,a_0):
    if N==0:
        a=a_0
        print("a_",N,"=", a)
        return a
    else:
        #print("a_",N-1,"=", recursive_a_N(N-1,a_0)) #what do you think will happen if we un-comment this?
        a=(1-2*recursive_a_N(N-1,a_0))/3
        print("a_",N,"=", a)
        return a

def recursive_a_N(N,a_0):
    if N==0:
        a=a_0
        print("a_",N,"=", a)
        return a
    else:
        #print("a_",N-1,"=", recursive_a_N(N-1,a_0)) #what do you think will happen if we un-comment this?
        a=(1-2*recursive_a_N(N-1,a_0))/3
        print("a_",N,"=", a)
        return a
recursive_a_N(15,1)

def recursive_a_N(N,a_0):
    if N==0:
        a=a_0
        print("a_",N,"=", a)
        return a
    else:
        #print("a_",N-1,"=", recursive_a_N(N-1,a_0)) #what do you think will happen if we un-comment this?
        a=(1-2*recursive_a_N(N-1,a_0))/3
        print("a_",N,"=", a)
        return a
recursive_a_N(15,1)  #check this was what we were expecting

"""#### Exercise 2(b): Recursive Functions for Recursive Sequences
Below, give a recursive version of `b_N`.
You no longer need include any `print` statements.
Be sure to check your `recursive_b_N` against the original `b_N` to make sure they give the same values.
"""

#YOUR CODE HERE
def recursive_b_N(N,b_0):
    if N==0:
        b=b_0
        print("b_",N,"=", b)
        return b
    else:
        b=((1+2*recursive_b_N(N-1,b_0))/4)
        print("b_",N,"=", b)
        return b
recursive_b_N(23,10000)

"""### Defaults, List Arguments, and Optional Arguments
One common technique in defining functions is to assign default values to arguments.
This is perhaps best illustrated by example.
"""

def print_if_you_like(String="no input provided"):
    print(String)
    return

print_if_you_like("here is a string provided by the user")

print_if_you_like(String="here's another way to call this function")

print_if_you_like()  #what do you expect the output to be?

"""Often, we'll need functions that take an unknown number of inputs.
There are two major ways of doing this: optional arguments and list arguments.
To demonstrate list arguments, here is a function which takes a list of numbers and adds them all up.
Note how the loop is set up!
"""

def list_sum(numlist=[]): #default to empty list
    tot=0                 #sum of nothing is 0
    for n in numlist:     #no need to call len(numlist)!
        tot+=n            #same as tot=tot+n
    return tot

list_sum([1,2,3,4])

list_sum()

"""Here is an essentially identical function using optional arguments instead.
Think of the asterisk `*` as declaring that there may be any number of arguments, which the function treats as a list called `numlist`.
"""

def optional_sum(*numlist):
    tot=0
    for n in numlist:
        tot+=n
    return tot

optional_sum()

optional_sum(1,2,-3,4)     #note the arguments are not enclosed in a list this time!

"""The following will throw an error. Uncomment the code line by removing the `#` at the beginning and see what the error says. Why do you think it occurred?"""

optional_sum(1,2,3,4)   #this doesn't work

"""#### Exercise 2(c) Optional and List Arguments of Your Own.
(i)Write functions `list_mult` and `optional_mult` which behave similarly to `list_sum` and `optional_sum` but instead multiply their arguments.

(ii)Then, write a function `arg_reader` which prints each of its arguments (say `arg`) and the number `n` of remaining terms in the format "reading `arg`, `n` arguments remain" then prints "all done!".
You may use either a list argument or optional arguments.

<details>
<summary>
    <b>
        Details for (ii)
    </b> (Click here to open)
</summary>
    
Example input (list version):
```python
arg_reader(["Nebraska","Wisconsin", 1/3,11/4,311/25])
```
Example input (optional argument version)
```python
arg_reader("Nebraska","Wisconsin", 1/3,11/4,311/25)
```
Output (both):
```
reading Nebraska . 4 arguments remain
reading Wisconsin . 3 arguments remain
reading 0.3333333333333333 . 2 arguments remain
reading 2.75 . 1 arguments remain
reading 12.44 . 0 arguments remain
all done!
```

    
</details>


<details>
    <summary>
        <b> Hint: </b>
        (click here to open)
    </summary>

- To print more complicated statements like this, `print` takes optional arguments!
  For example:
```python
a=1
b=2
c="red"
d="blue"
print(a,"fish",b,"fish",c,"fish",d,"fish")
```
returns
```
1 fish 2 fish red fish blue fish
```

</details>
"""

def list_mult(numlist=[]):
    tot=1
    for n in numlist:
        tot=tot*n
    return tot

def optional_mult(*numlist):
    tot=1
    for n in numlist:
        tot*=n
    return tot

def arg_reader(*numlist):
    tot=0
    len_list=len(numlist)
    for n in numlist:
        tot=tot+1
        print(f"reading {n} . {len_list-tot} arguments remain")
    return print("all done!")

arg_reader(1,"blue",3,1)

"""___

## Introducing NumPy
The very first thing to do with any library we utilize is to *import* it into the current project:
"""

import numpy as np

"""This allows us to use the library's functions and objects.
To see a list of these, type `np.` into a cell and hit the "Tab" key--this will bring up the sublibraries and functions available.

### The `np.ndarray`
The basic object offered by `numpy` is the `ndarray` data type.
One can instantiate an `ndarray` with the `np.array` function, as below.
`np.array` takes a list as input.
For a multidimensional array (such as a matrix), we use a list of lists, with each inner list representing a row.

In certain applications, `ndarray`s with `int` entries can have unexpected behavior.
To prevent this, we'll explicitly *declare* the type as `float64` when calling `np.array`--you are encouraged to get in the habit of including the `"float64"` at the end, as below.
"""

A=np.array([[1,2],[3,4]],"float64")
type(A)

"""You can check the number of dimensions of an `ndarray` with the `ndim` method:"""

A.ndim

"""Every `ndarray` has a `shape`, giving its dimensions."""

A.shape #what do you expect it to be?

"""Since `A` is a two-dimensional array with two rows and two columns, it has shape `(2,2)`.
**Throughout these activities, we will be using the term "matrix" as a synonym for 2-dimensional `ndarray`.**
"""

v=np.array([1,-3],"float64")
v.ndim

v.shape

"""One can also use syntax similar to that of for loops to construct `ndarray`s.
This will be a crucial tool for us.
"""

w=np.array([k**2 for k in range(5)],"float64")
w

B=np.array([[i-j/2 for j in range(5)] for i in range(2)],"float64")
B

"""Indexing is similar to before, but now we can supply multiple index arguments."""

B[1] #the 1-indexed row

print(B[1][2]) #the 2-indexed entry of the 1-indexed row\
print(B[1,2]) #this is exactly the same

"""A crucial technique for working with `ndarray`s is *slicing*.
This allows us to take submatrices.
For instance, suppose we want to extract the middle column of `B`:
"""

c=B[:,2]  #colon in first entry means ranging from beginning to end, 2 in second entry specifies column
c

c.shape #notice that numpy automatically stores it in as few dimensions as possible

"""Beyond extracting columns, one can extract larger submatrices."""

B[:,1:] # all columns starting with column 1

"""#### Exercise 3: Constructing and Slicing Matrices
**(a)** In the cell below, construct a $5\times 6$ matrix $C=(\frac{i+1}{j+1})_{ij}$.
That is, your code should produce the matrix $$
\begin{pmatrix}
1 & \frac{2}{3} & \frac{1}{2} & \frac25 &\frac13 & \frac27\\
\frac32 & 1 & \frac{3}{4} & \frac35&\frac12 & \frac37\\
2 & \frac{4}{3} & 1 & \frac45 &\frac23 & \frac47\\
\frac52 & \frac{5}{3} & \frac{5}{4} & 1 &\frac56 & \frac57\\
3 &2 & \frac{3}{2} & \frac65 &1 & \frac67
\end{pmatrix}.$$

Be sure to account for Python indexing conventions! (i.e. starting at 0). You may need to adjust your formula to do so.

"""

C=np.array([[((i/2+1)/(j/2+1)) for j in range(6)] for i in range(5)],"float64")
C

"""___

**(b):** Use *slicing* to extract the third row (that is $\begin{pmatrix}2&\frac43&1&\frac45&\frac23&\frac47\end{pmatrix}$) and the fourth column (that is $\begin{pmatrix}\frac25&\frac35&\frac45&1&\frac65\end{pmatrix}$) as vectors `u_1` and `u_2` respectively. Do **not** use any other method to do so.
"""

u_1=C[2]
print(u_1)

u_2=C[:,3]
print(u_2)

"""___

**(c):** Use slicing to extract the submatrix `C_abridged` which only has the second through fourth rows and third and fourth column.
That is, your code should produce the matrix
$$
\begin{pmatrix}
 \frac{3}{4} & \frac35\\%&\frac12 & \frac37\\
1 & \frac45\\% &\frac23  \frac47\\
 \frac{5}{4} & 1% &\frac56 & \frac57\\
\end{pmatrix}
$$
"""

C_abridged=C[1:4,2:4]
print(C_abridged)

"""___

**(d)** [View vs. Copy]

- (i) Change the 3/4 in the second row of `C` to 99. Does that change `C_abridged`?
- (ii) Change the 1 in the second row of `C_abridged` to -99. Does that change `C`?
- (iii) Enter in the line `C_new=C.copy()`, then change the second row of `C_new` to five times the first. Does that change `C`?
- (iv) Summarize your findings below.
"""

C[1,2]=99
print(C_abridged)

C_abridged[1,0]=-99
print(C)

C_new=C.copy()
C_new[1]=[7.5, 5, 198, 3, 2.5, 15/7]
print(C)

"""Yes, yes, no

___

Matrix multiplication is implemented with `np.dot` for compatibly sized arrays.
"""

M=np.array([[((-2/3)**i)+(3/5)**j for j in range(5)] for i in range(2)],"float64")
N=np.array([[(-3/2)**i*(4/7)**j for j in range(3)] for i in range(5)],"float64")
print(M.shape,N.shape)
MN=np.dot(M,N)
print(MN)
print(MN.shape)

"""This works even mixing dimensions."""

print(A.shape,v.shape)

Av=np.dot(A,v)
Av.shape,Av

"""#### Exercise 4: Please just trust me on this, you'll be glad you did this one
Use optional arguments to write a function which takes one or more matrices of compatible definitions $A_1,A_2,\dots,A_n$ and returns the matrix product $A_1A_2\dots A_n$.

<details>
<summary>
<b>
    Hint:
</b>
    (Click here to open)
</summary>
    
-    Note that unlike our sums and products of before, this suggests taking one or more input matrices rather than zero or before. Why might that be? In any case, you can have both required and optional arguments in the form (say) `def mult(A,*Bs):`
    
</details>
"""

#YOUR CODE HERE
def mult(A, *Bs):
    for n in Bs:
        A=np.dot(A,n)
    return A

#testing
v_1=np.array([2**i for i in range(4)],"float64")
A_1=np.array([[i+j for j in range(5)]  for i in range(4)],"float64")
A_2=np.array([[1/(i+j+1) for j in range(5)] for i in range(5)],"float64")
A_3=np.array([[i-j for j in range(6)] for i in range(5)],"float64")
v_2=np.array([1/2**i for i in range(6)],"float64")
mult(v_1,A_1,A_2,A_3,v_2)
#desired output:
#425.32607886904765

